using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace Tmtxt.StaticHelpers
{
    /// <summary>
    /// Static helper class to port some crypto features of the library crypto-js to C#
    /// </summary>
    public static class CryptoJsStaticHelper
    {
        /// <summary>
        /// <para>C# version of cryptojs.AES.decrypt(encryptedString, passphrase).toString(cryptojs.enc.Utf8)</para>
        /// <para>To use AES encryption, you need to pass in a Key and a random IV - Initialization Vector (the
        /// IV is used to add randomness to your encryption process)</para>
        /// <para>In crypto-js, if you pass a passphrase into the "encrypt" function,
        /// for example <code>cryptojs.AES.encrypt(message, passphrase).toString()</code>,
        /// the Key and the IV will be created automatically</para>
        /// <para>In order to derive a key from the passphrase, it uses the OpenSSL-compatible derivation function
        /// EVP_BytesToKey. This mode generates a new 8 byte random salt and uses it along with the password to generate
        /// the Key and IV. See <see cref="DeriveKeyAndIv"/> for more info.</para>
        /// <para>This <code>cryptojs.AES.encrypt(message, passphrase).toString()</code> results in a Base64-encoded
        /// ciphertext that contains the string "Salted__" at the beginning followed by the 8 byte salt and the actual
        /// ciphertext. That means, the first 8 bytes are for the text "Salted__", the next 8 bytes are for the salt and
        /// the remaining bytes are the actual ciphertext</para>
        /// <para>Here are the steps to decrypt the base64 string generated by cryptojs</para>
        /// <para>- Convert the base64 string back to a byte array</para>
        /// <para>- Omit the first 8 bytes (for the "Salted__" string)</para>
        /// <para>- Take the next 8 bytes as the salt</para>
        /// <para>- Take the remaining bytes as the ciphertext</para>
        /// <para>- Use the utility function <see cref="DeriveKeyAndIv"/> to generate the Key and the IV</para>
        /// <para>- Input the ciphertext, the key and the iv into AES decryptor to get the final string</para>
        /// </summary>
        /// <param name="encryptedString"></param>
        /// <param name="passphrase"></param>
        /// <returns></returns>
        public static string DecryptAes(string encryptedString, string passphrase)
        {
            // encryptedString is a base64-encoded string starting with "Salted__" followed by a 8-byte salt and the
            // actual ciphertext. Split them here to get the salted and the ciphertext
            var base64Bytes = Convert.FromBase64String(encryptedString);
            var saltBytes = base64Bytes[8..16];
            var cipherTextBytes = base64Bytes[16..];

            // get the byte array of the passphrase
            var passphraseBytes = Encoding.UTF8.GetBytes(passphrase);

            // derive the key and the iv from the passphrase and the salt, using 1 iteration
            // (cryptojs uses 1 iteration by default)
            DeriveKeyAndIv(passphraseBytes, saltBytes, 1, out var keyBytes, out var ivBytes);

            // create the AES decryptor
            using var aes = Aes.Create();
            aes.Key = keyBytes;
            aes.IV = ivBytes;
            // here are the config that cryptojs uses by default
            // https://cryptojs.gitbook.io/docs/#ciphers
            aes.KeySize = 256;
            aes.Padding = PaddingMode.PKCS7;
            aes.Mode = CipherMode.CBC;
            var decryptor = aes.CreateDecryptor(keyBytes, ivBytes);

            // example code on MSDN https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.aes?view=net-5.0
            using var msDecrypt = new MemoryStream(cipherTextBytes);
            using var csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read);
            using var srDecrypt = new StreamReader(csDecrypt);

            // read the decrypted bytes from the decrypting stream and place them in a string.
            return srDecrypt.ReadToEnd();
        }

        /// <summary>
        /// <para>C# equivalent method of EVP_BytesToKey in OpenSSL
        /// https://stackoverflow.com/questions/8008253/c-sharp-version-of-openssl-evp-bytestokey-method</para>
        /// <para>Generate the Key and the IV from the input Passphrase and the Salt</para>
        /// </summary>
        /// <param name="passphrase"></param>
        /// <param name="salt"></param>
        /// <param name="iterations">How many iterations to perform hash</param>
        /// <param name="key">The output 32 byte key</param>
        /// <param name="iv">The output 16 byte iv</param>
        private static void DeriveKeyAndIv(byte[] passphrase, byte[] salt, int iterations, out byte[] key, out byte[] iv)
        {
            var hashList = new List<byte>();

            var preHashLength = passphrase.Length + (salt?.Length ?? 0);
            var preHash = new byte[preHashLength];

            Buffer.BlockCopy(passphrase, 0, preHash, 0, passphrase.Length);
            if (salt != null)
                Buffer.BlockCopy(salt, 0, preHash, passphrase.Length, salt.Length);

            var hash = MD5.Create();
            var currentHash = hash.ComputeHash(preHash);

            for (var i = 1; i < iterations; i++)
            {
                currentHash = hash.ComputeHash(currentHash);
            }

            hashList.AddRange(currentHash);

            while (hashList.Count < 48) // for 32-byte key and 16-byte iv
            {
                preHashLength = currentHash.Length + passphrase.Length + (salt?.Length ?? 0);
                preHash = new byte[preHashLength];

                Buffer.BlockCopy(currentHash, 0, preHash, 0, currentHash.Length);
                Buffer.BlockCopy(passphrase, 0, preHash, currentHash.Length, passphrase.Length);
                if (salt != null)
                    Buffer.BlockCopy(salt, 0, preHash, currentHash.Length + passphrase.Length, salt.Length);

                currentHash = hash.ComputeHash(preHash);

                for (var i = 1; i < iterations; i++)
                {
                    currentHash = hash.ComputeHash(currentHash);
                }

                hashList.AddRange(currentHash);
            }

            hash.Clear();
            key = new byte[32];
            iv = new byte[16];
            hashList.CopyTo(0, key, 0, 32);
            hashList.CopyTo(32, iv, 0, 16);
        }
    }
}
