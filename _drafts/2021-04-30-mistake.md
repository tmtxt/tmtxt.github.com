---
layout: post
title: "Mistakes of a Software Engineer - Favor NoSQL over SQL"
description: ""
categories: [misc]
tags: []
thumbnail:
---

I can talk about this topic for the whole day.

> It doesn't mean that I hate NoSQL. I just want to use the right tool for the right job...

This post is written from my experience. This may be true at this time but who knows what will
change in the future? I have faced a lot of problems with the design of NoSQL, especially when it's
the main backing service for the whole system. Each database has its own strength and weakness and
we should use it for the most suitable job or at least, pick the one that can solve 80% of your
problems and live with the other 20% pain instead of choosing the one that fits for 20% use cases
and fix the problem that it brings to the other 80%.

> By NoSQL, I mean Document database systems (Mongo DB for example)

# A real life loop

Back in the 1970s, the most popular database used a simple data model called the hierarchical model,
which is similar to JSON model used in document databases today. That model works well for
one-to-many relationships (or at least, that's what they claim). However, when it comes to
many-to-many relationships, this design exposes a whole lot of problems, from joining issue to
duplicate data management. The two alternative solutions were proposed. They are Relational model
and Network model. The fact is obvious, Relational model wins the long run.

It seems that NoSQL
databases today are repeating the problems in the history, which have been solved for decades.
Despite the debate about the advantages of a more flexible data schema or a better representation of
data (which is more similar to objects in programming language), the 1970s' problems still exist and
developers still have to handle those things manually in an awkward way.

# The problem of Document Storage model

Usually for NoSQL, you are encouraged to store the object and its relationship in one single
document instead of following the 3 forms of database normalization. For example, for an Insurance
AMS system, a customer object would also contain the list of all its contacts (spouse, parents or
children), the list of all the policies this customer has purchased and a collection of all the
claims this customer has made. This leads to a table consisting of multiple large documents. So what
is the problem here?

- What if you just want to read some fields of the customer object (`firstName`, `lastName` or
  `emailAddress`)?
- What if you only want to update some fields of the customer object?

Unless the field you want to work with stays on the
[index tree](https://rethinkdb.com/docs/memory-usage#internal-metadata),
I cannot imagine there is any
solution to interact with individual field in an optimal way. The database system has to load the
whole document to memory to process, to read only some specific props, to update only some fields
and then write the whole document back to disk.

- What if your customer object contains a lot of policies? It can be a Commercial customer (a
  Company buying insurance for all its employees). The whole object will be loaded to memory just to
  get/set some fields.
- Even if you store small objects, what will happen if you read/update just one field in millions of
  object? All related documents will be loaded into memory just to get some specific fields.

We had this problem in the past. We simply store the objects without worrying about the size of each
record until we realized it was a big problem. All the solutions lead to a SQL design!

Why don't just use SQL from the beginning?

# A Non-Relational world?

> **Relations** still exist in these NoSQL databases, but...

You can still organize your entities into different tables (or collections in Mongodb), but
that's not the design philosophy of those Document database systems. They encourage you to combine
the related entities into just one single object, especially for one-to-many relationships. It best
fits for the case you just want to interact with the parent objects. The real world is a lot more
complex than that.

Take a look at this example. You are building an application to automate email marketing for your
insurance agency. Initially, the application targets the customers of the agency only. To support
that, you only need a table `customers` to store customer objects with some basic fields. As your
application grows, the client requests to add some policies information into the email message (a
list of policies that the customer has purchased, for example). You will then update the objects in
that table to include a new array field called `policies`. That works perfectly and your business
keeps growing. You decided to add more features to work with Policy entity type. Now, you have 2
choices

The first option is to keep the current table structure, add more fields into the `policies` array
property of the `customer` object. This solution is backward-compatible, doesn't require any changes
to the current application software. However, you will soon realize the troubles. It will come back
to the problem of large objects that I mentioned above. It will affect the performance of all other
read/write operations. You will pay the panalty when interacting with only some fields of the
customer object. Another problem is that it's hard to work with the Policy objects directly. You
will always have to go through the parent customer object. To retrieve a single policy, you will
have to query the parent customer, load the whole object into memory (either database memory or
application memory), filter to the policy that you are looking for and then return it. To query the
list of policies and then sort by some conditiion, you have to query all the customer objects in the
system just to get the policy data and then aggregate them. Your application code logic will be more
and more complex, the performance of your application will keep decreasing.

Another way is to create another `policies` table to support for policy-related features. If you
keeps the existing `customers` table structure, you will have to deal with the duplicated data
problem. How to maintain the consistency between the 2 tables? That should be the database job,
shouldn't it? Now, it's likely that you have to maintain by your own on application level.
What happens if you instead decided to just store the policy data in the `policies` table?

# There is nothing called Schemaless
